1.5.1 特点：
1.存取是无序的，实现不同步，线程不安全。
2.键和值都是可以为null的，但是键只能是一个null
3.键是唯一的，它是由底层的数据结构控制的。
4.jdk1.8之前底层结构是  数组+链表   1.8之后是  数组+链表+红黑树  （链表是为了解决哈希冲突
哈希冲突：两个对象调用hashcode方法计算哈希码值的时候可能会出现相同的，那么就会导致数组的索引相同。以此引发哈希冲突/）
5.阈值大于8且数组长度大于64，才会将链表转换为红黑树，变为红黑树是为了更高效的查询。
1.5.2 面试题
哈希表中底层采用何种算法计算hash值？还有那些算法可以计算出hash值？
底层采用的key的hashCode方法的值结合数组的长度进行无符号位右移（>>>）,按位异或（^）,按位与（&）计算出索引，
还可以采用：平方取中法，取余数法，伪随机数法。
当两个对象的hashCode相等时会怎么样？
会发生哈希碰撞，若Key值相等则替换旧的value,不然连接到链表后面，链表长度超过阈值8就转换为红黑树
何时发生哈希碰撞，如何解决？
当两个key值相等的时候会发生哈希碰撞/  jdk1.8之前是利用链表解决哈希碰撞的，jdk1.8之后是利用链表+红黑树处理哈希碰撞的。
如果两个键的hashCode相同，如何存储键值对？
如果说两个键的hashCode相同，value值不同，则会将新的键值对存储到哈希表中。
如果两个键的hashCode相同。value也相同，则会将新值覆盖旧值。